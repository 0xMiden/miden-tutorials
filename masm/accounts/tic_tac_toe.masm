use.miden::account
use.miden::account_id
use.std::sys

# PROCEDURES:
# "constructor" / "start"
# make_a_move
# end (identify win or draw)

# STORAGE:
# PLAYER1 SLOT
# PLAYER2 SLOT
# BOOLEAN_SLOT
# MAPPING_SLOT
#
# player1 ID
# player2 ID
# boolean flag who is next to play
# mapping (field values)

const.ERR_WRONG_PLAYER="Wrong player trying to make move"
const.ERR_NO_WINNER="There is no winner or draw"

const.PLAYER1_SLOT=0
const.PLAYER2_SLOT=1
const.FLAG_SLOT=2
const.MAPPING_SLOT=3

# => [player1_prefix, player1_suffix, player2_prefix, player2_suffix]
export.constructor
    # store player1 ID by padding value to size of one word
    push.0.0 push.PLAYER1_SLOT
    # [player1_slot, 0, 0, player1_prefix, player1_suffix, player2_prefix, player2_suffix]

    exec.account::set_item
    # [OLD_VALUE, player2_prefix, player2_suffix]

    # drop old value from stack
    dropw
    # [player2_prefix, player2_suffix]

    # pad to word
    push.0.0 push.PLAYER2_SLOT
    # [player2_slot, 0, 0, player2_prefix, player2_suffix]

    # store player2 ID
    exec.account::set_item
    # [OLD_VALUE]

    # Drop old value from stack (returned by set_item call)
    dropw
    # []
end

# => [caller_prefix, caller_suffix, field_index]
export.make_a_move
    # Stack: [caller_prefix, caller_suffix, field_index]

    # verify caller ID is in line with current player
    push.FLAG_SLOT exec.account::get_item
    # [FLAG, caller_prefix, caller_suffix, field_index]

    # Push zero (to compare to zero)
    padw
    # [0WORD, FLAG, caller_prefix, caller_suffix, field_index]

    # Check if equal
    eqw
    # [is_true, 0WORD, FLAG, caller_prefix, caller_suffix, field_index]

    if.true
        # delete 0WORD & FLAG
        dropw dropw
        # [caller_prefix, caller_suffix, field_index]

        push.PLAYER1_SLOT push.1
        # [1, player1_slot, caller_prefix, caller_suffix, field_index]
        movdn.4
        # [player1_slot, caller_prefix, caller_suffix, field_index, 1]
    else
        # delete 0WORD & FLAG
        dropw dropw
        # [caller_prefix, caller_suffix, field_index]

        push.PLAYER2_SLOT push.2
        # [2, player2_slot, caller_prefix, caller_suffix, field_index]
        movdn.4
        # [player2_slot, caller_prefix, caller_suffix, field_index, 2]
    end

    exec.account::get_item
    # [0, 0, player_prefix, player_suffix, caller_prefix, caller_suffix, field_index, move_value]

    # Remove trailing zero's of word
    drop drop
    # [player_prefix, player_suffix, caller_prefix, caller_suffix, field_index, move_value]

    exec.account_id::is_equal assert.err=ERR_WRONG_PLAYER
    # [field_index, move_value]

    dup dup dup
    # [FIELD_INDEX, move_value]

    dup.4 dup.5 dup.6 movup.7
    # [MOVE_VALUE, FIELD_INDEX]

    swapw
    # [FIELD_INDEX, MOVE_VALUE]

    push.MAPPING_SLOT
    # [mapping_slot, FIELD_INDEX, MOVE_VALUE]

    exec.account::set_map_item
    # [OLD_MAP_ROOT, OLD_MAP_VALUE]

    dropw dropw

    debug.stack

    # TODO: verify that field can be played on (not yet placed by other player)
end

# export.end_game
    # verify player has won game OR that draw

    # store winning lines
    # exec.check_line 0 1 2
    # exec.check_line 3 4 5
    # exec.check_line 6 7 8
    # exec.check_line 0 3 6
    # exec.check_line 1 4 7
    # exec.check_line 2 5 8
    # exec.check_line 0 4 8
    # exec.check_line 2 4 6

    # per line, check if all of the boxes have same value (except 0)

    # if fails => check if cell left that is not 0
    # if not => draw
    # if there is lift => return error (no winner found)
# end

export.check_line
    push.MAPPING_SLOT
    # [slot, index1, index2, index3]
end

# export.check_draw
    # check that each item of mapping has equal value except zero (=> win)
# end