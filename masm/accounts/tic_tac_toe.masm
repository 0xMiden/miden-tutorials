use.miden::account
use.miden::note
use.miden::account_id

const.ERR_WRONG_PLAYER="Wrong player trying to make move"
const.ERR_WRONG_PLAYER_SLOT="Wrong player slot supplied"
const.ERR_NO_WINNER="There is no winner or draw"

const.PLAYER1_SLOT=0
const.PLAYER2_SLOT=1
const.FLAG_SLOT=2
const.WINNER_SLOT=3
const.MAPPING_SLOT=4

# => [player1_prefix, player1_suffix, player2_prefix, player2_suffix]
export.constructor
    # store player1 ID by padding value to size of one word
    push.0.0 push.PLAYER1_SLOT
    # [player1_slot, 0, 0, player1_prefix, player1_suffix, player2_prefix, player2_suffix]

    exec.account::set_item
    # [OLD_VALUE, player2_prefix, player2_suffix]

    # drop old value from stack
    dropw
    # [player2_prefix, player2_suffix]

    # pad to word
    push.0.0 push.PLAYER2_SLOT
    # [player2_slot, 0, 0, player2_prefix, player2_suffix]

    # store player2 ID
    exec.account::set_item
    # [OLD_VALUE]

    # Drop old value from stack (returned by set_item call)
    dropw
    # []
end

# => [caller_prefix, caller_suffix, field_index]
# TODO: verify field_index is not greater than 8
# TODO: verify that field_index can be played upon (has zero value)
export.make_a_move
    exec.note::get_sender
    # Stack: [caller_prefix, caller_suffix, field_index]

    # verify caller ID is in line with current player
    push.FLAG_SLOT exec.account::get_item
    # [FLAG, caller_prefix, caller_suffix, field_index]

    # Push zero (to compare to zero)
    padw
    # [0WORD, FLAG, caller_prefix, caller_suffix, field_index]

    # Check if equal
    eqw
    # [is_true, 0WORD, FLAG, caller_prefix, caller_suffix, field_index]

    if.true
        # delete 0WORD & FLAG
        dropw dropw
        # [caller_prefix, caller_suffix, field_index]

        push.PLAYER1_SLOT push.1
        # [1, player1_slot, caller_prefix, caller_suffix, field_index]
        movdn.4
        # [player1_slot, caller_prefix, caller_suffix, field_index, 1]
    else
        # delete 0WORD & FLAG
        dropw dropw
        # [caller_prefix, caller_suffix, field_index]

        push.PLAYER2_SLOT push.2
        # [2, player2_slot, caller_prefix, caller_suffix, field_index]
        movdn.4
        # [player2_slot, caller_prefix, caller_suffix, field_index, 2]
    end

    exec.account::get_item
    # [0, 0, player_prefix, player_suffix, caller_prefix, caller_suffix, field_index, move_value]

    # Remove trailing zero's of word
    drop drop
    # [player_prefix, player_suffix, caller_prefix, caller_suffix, field_index, move_value]

    exec.account_id::is_equal assert.err=ERR_WRONG_PLAYER
    # [field_index, move_value]

    dup dup dup
    # [FIELD_INDEX, move_value]

    dup.4 dup.5 dup.6 movup.7
    # [MOVE_VALUE, FIELD_INDEX]

    swapw
    # [FIELD_INDEX, MOVE_VALUE]

    push.MAPPING_SLOT
    # [mapping_slot, FIELD_INDEX, MOVE_VALUE]

    exec.account::set_map_item
    # [OLD_MAP_ROOT, OLD_MAP_VALUE]

    dropw dropw
end

# => [player_slot]
export.end_game
    # TODO: check that player slot is smaller than 2
    dup push.3 lt assert.err=ERR_WRONG_PLAYER_SLOT
    # [player_slot]

    # push all indexes onto stack
    push.0.0.1.2
    mem_storew.1 dropw

    push.0.3.4.5
    mem_storew.2 dropw

    push.0.6.7.8
    mem_storew.3 dropw

    push.0.0.3.6
    mem_storew.4 dropw

    push.0.1.4.7
    mem_storew.5 dropw

    push.0.2.5.8
    mem_storew.6 dropw

    push.0.0.4.8
    mem_storew.7 dropw

    push.0.2.4.6
    mem_storew.8 dropw

    # push i for loop
    push.1 # !!!TODO: EDIT THAT!!!
    dup neq.0
    # [true, i, player_slot]

    # check stack size to determine if exiting or not
    while.true
        # [i, player_slot]
        
        dup movdn.2 padw
        # [0, 0, 0, 0, i, player_slot, i]

        debug.stack

        movup.4 mem_loadw
        # [0, index, index, index, player_slot, i]

        drop
        # [index, index, index, player_slot, i]

        exec.check_line
        # [is_win, player_slot, i]

        if.true
            drop drop
            # Add win logic
        end

        swap
        # [i, player_slot]

        sub.1
        # [i-1, player_slot]

        dup neq.0
        # [true/false, i-1, player_slot]
    end

    # if fails => check if cell left that is not 0
    # if not => draw
    # if there is lift => return error (no winner found)
end

# => [key1, key2, key3, player_slot]
proc.check_line
    # add i to stack
    push.3
    # [i, key1, key2, key3, player_slot]
    dup neq.0
    # [true, i, key1, key2, key3, player_slot]

    while.true
        sub.1
        # [i-1, key_or_value, key_or_value, key_or_value, player_slot]

        # Move index to end
        movdn.4
        # [key_or_value, key_or_value, key_or_value, player_slot, i-1]

        exec.retrieve_board_value movdn.2
        # [key_or_value, key_or_value, value, player_slot, i-1]

        # move index to top
        movup.4
        # [i-1, key_or_value, key_or_value, value, player_slot]

        dup neq.0
    end
    # [0, value3, value2, value1, player_slot]

    drop
    # [value3, value2, value1, player_slot]

    swap.3
    # [player_slot, value3, value2, value1]

    # compute player value
    add.1
    # [player_value, value3, value2, value1]

    dup dup dup dup dup
    # [player_value, PLAYER_VALUE, player_value, value3, value2, value1]

    sub.1 movdn.8
    # [PLAYER_VALUE, player_value, value3, value2, value1, player_slot]

    eqw
    # [is_equal, PLAYER_VALUE, player_value, value3, value2, value1, player_slot]

    movdn.8 dropw dropw
    # [is_equal, player_slot]
end

# proc.check_draw
    # check that each item of mapping has equal value except zero (=> win)
# end

# [key]
proc.retrieve_board_value
    dup dup dup

    push.MAPPING_SLOT

    exec.account::get_map_item

    # remove trailing empty fields
    drop drop drop  
end